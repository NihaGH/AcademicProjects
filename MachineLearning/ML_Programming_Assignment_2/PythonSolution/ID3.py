import csvimport numpy as npimport mathimport argparsetreeBool = FalsexmlObj = []*5def countRowsColumns(data):    # returns the number of rows and columns in the input data.     #Column can be used to identify the Class as it is the last column of the input data     rows, column = data.shape    return rows, columndef returnUnique(data, column):    #return Unique values with Value name and count of values in the column     uniqueVal = []    unique, counts = np.unique(data[:,column], return_counts=True)    uniqueVal = np.asarray((unique, counts)).T    return uniqueValdef insertName(data, column):    #insert labels like - att0, att1 and so on to all the columns    a=[]    for i in range(column-1):        a.append("att" +str(i))    a.append("class")    b= np.insert(data,0,a,axis=0)    return b    def calculateTotalEntropy(classAttribute):    #calculates total entropy or Entroy(S) for all the classes of the dataset.     total = 0    entropy = 0    for i in range(len(classAttribute)):        total = total + int(classAttribute[i][1])    for i in range(len(classAttribute)):        val = int(classAttribute[i][1])/total        ent = - (val * math.log(val,len(classAttribute)))        entropy = entropy +ent    return entropy                def calculateValueEntropy(data, col, val,classAttribute):    #calculates entropy of each class value and attribute    rows, classCol = countRowsColumns(data)    classCol = classCol-1    valArr = []*2    countVal = 0    for iclas in range(len(classAttribute)):        countVal = 0        for icol in range(len(data)):            classVal = str(classAttribute[iclas][0])            dataClassVal = str(data[icol][classCol])            dataVal = str(data[icol][col])            if((classVal==dataClassVal) and (dataVal == val)):                countVal += 1        if(countVal > 0):            valArr.append(np.asarray((classVal, countVal)).T)    #calcuate and return entropy of the attribute    total = 0    entropy = 0    for i in range(len(valArr)):        total = total + int(valArr[i][1])    for i in range(len(valArr)):        temp_val = float(valArr[i][1])/total        ent = - (temp_val * math.log(temp_val,len(classAttribute)))        entropy = entropy +ent    return entropydef calculateNodeEntropy(data,col,classAttribute):    #Calculates entropy of each node that will depend upon its values and their classes    attribute = returnUnique(data, col)    E = []    for row in range(len(attribute)):        entropy = calculateValueEntropy(data,col, attribute[row][0],classAttribute)        E.append(np.asarray((attribute[row][0],attribute[row][1], entropy)))    myE = np.asarray(E)    return myE        def returnNodeEntropy(data,col,classAttribute):    #calculate and returns total Entropy of a node.    myE = []    myE.append(np.asarray(calculateNodeEntropy(data,col,classAttribute)))    E = np.asarray(myE)    nodeEntropy = 0    nETemp = 0    totalRows = 0    totalRows, col1 = countRowsColumns(data)    for irow in range(len(E[0])):        Sv = float(E[0][irow][1])        Stotal = float(totalRows)        Sentropy = float(E[0][irow][2])        nETemp = Sv/Stotal * Sentropy        nodeEntropy = nodeEntropy + nETemp    return nodeEntropy    def writeXML(dataLabel,xmlObj,outputfileName):    #write solution into the given output file    xmlObj = np.asarray(xmlObj)    xmlFile = open(outputfileName, 'w')    cntOpen = 0    cntClose = 0    for i in range(len(xmlObj)-1):        tType = str(xmlObj[i][0])        entropy = str(xmlObj[i][1])        imax = int(xmlObj[i][2])        feature = str(dataLabel[0][imax])        value = str(xmlObj[i][3])        clas = str(xmlObj[i][4])        depth = int(xmlObj[i][5])        cntOpen = cntOpen+1        if(i==0):            st = '<tree entropy="' + str(entropy) + '">'            xmlFile.write(st)        elif(i<len(xmlObj)-1):            if(tType == "LeafNode"):                st = '<node entropy="' + str(entropy) + '" feature="'+str(feature)+'" value="'+str(value)+'">'+str(clas)+"</node>"                xmlFile.write(st)                if int(xmlObj[i][5]) > int(xmlObj[i+1][5]):                    diff = int(xmlObj[i][5]) - int(xmlObj[i+1][5])                    nend ="</node>"                    for x in range(diff-1):                        nend = nend +"</node>"                    cntClose = cntClose+1                    xmlFile.write(nend)            elif(tType == "Node"):                st = '<node entropy="' + str(entropy) + '" feature="'+str(feature)+'" value="'+str(value)+'">'                xmlFile.write(st)                if int(xmlObj[i][5]) > int(xmlObj[i+1][5]):                    diff = int(xmlObj[i][5]) - int(xmlObj[i+1][5])                    nend ="</node>"                    for x in range(diff-1):                        nend = nend +"</node>"                    cntClose = cntClose+1                    xmlFile.write(nend)        if(i==(len(xmlObj)-2)):            if(tType == "LeafNode"):                st = '<node entropy="' + str(entropy) + '" feature="'+str(feature)+'" value="'+str(value)+'">'+str(clas)+"</node>"            elif(tType == "Node"):                st = '<node entropy="' + str(entropy) + '" feature="'+str(feature)+'" value="'+str(value)+'">'            xmlFile.write(st)            if int(xmlObj[i+1][5])>1:                    diff = int(xmlObj[i+1][5]) - 1                    nend ="</node>"                    for x in range(diff-1):                        nend = nend +"</node>"                    cntClose = cntClose+1                    xmlFile.write(nend)    xmlFile.write("</tree>")    xmlFile.close    def redoData(data,imax,rootNodeVal):    #filters the data for a particular path    data2 = []    i = int(imax)    for irow in range(len(data)):        if data[irow][i] == str(rootNodeVal):            data2.append(data[irow])    datatemp = np.asarray(data2)    return datatempdef calculate_Node(data,dataLabel,col,classAttribute,depth):    #calculates and select the nodes of the decision tree    iGain = 0    attrEntropy = []    entropyS = float(calculateTotalEntropy(classAttribute))    global treeBool    global xmlObj    if treeBool == False:        #here 4th and 6th arguments are important others are kept to call method without error        xmlObj.append(("tree",entropyS,"1","b","c","0"))        treeBool = True    for i in range(col-1):        att = str(dataLabel[0][i])        attrsumEnt = float(returnNodeEntropy(data,i,classAttribute))        iGain = entropyS - attrsumEnt        attrEntropy.append(np.asarray((att, attrsumEnt,iGain)).T)    arr = np.asarray(attrEntropy)    a1=[]    #finds out Root Node's index based on information Gain of the attributes    for i in range(len(arr[:,2])):        a1.append(float(arr[i][2]))    imax = np.argmax(a1)    #copies Root Node Values and respective Entropies    rootNode =calculateNodeEntropy(data,imax,classAttribute)    depth = depth+1    for i in range(len(rootNode)):        data2 =[]        #cBool = False        rootNodeVal = float(rootNode[i][2])        if(rootNodeVal == 0.0):            for x in range(len(data)):                if data[x][imax] == rootNode[i][0]:                    cVar = data[x][col-1]            xmlObj.append(("LeafNode",rootNode[i][2],imax,rootNode[i][0],cVar,depth))                     else:            datatemp = redoData(data,imax,rootNode[i][0])            xmlObj.append(("Node",rootNode[i][2],imax,rootNode[i][0],rootNode[i][1],depth))            calculate_Node(datatemp,dataLabel,col,classAttribute,depth)        if __name__ == "__main__":    parser = argparse.ArgumentParser(description='ID3 Decision Tree')    parser.add_argument("--InputFileName", type= str )    parser.add_argument("--OutputFileName", type=str)    args = parser.parse_args()    filename = args.InputFileName    outputfileName = args.OutputFileName    data = np.loadtxt(filename, delimiter = ',', dtype = str)    rows, column = countRowsColumns(data)    classAttribute = returnUnique(data,column-1)    dataLabel = insertName(data,column)    depth = 0    calculate_Node(data,dataLabel,column,classAttribute,depth)    writeXML(dataLabel,xmlObj,outputfileName)    